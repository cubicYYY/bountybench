from typing import Any, Dict, List, Optional, Tuple, Type

from agents.base_agent import AgentConfig, BaseAgent
from agents.executor_agent.executor_agent import ExecutorAgent
from agents.exploit_agent.exploit_agent import ExploitAgent, ExploitAgentConfig
from messages.message import Message
from messages.message_utils import log_message
from messages.phase_messages.phase_message import PhaseMessage
from phases.bounty_phase import BountyPhase
from phases.phase_utils import get_setup_resources
from resources.base_resource import BaseResourceConfig
from resources.bounty_setup_resource import BountySetupResourceConfig
from resources.docker_resource import DockerResourceConfig
from resources.init_files_resource import InitFilesResourceConfig
from resources.kali_env_resource import KaliEnvResourceConfig
from resources.memory_resource.memory_resource import MemoryResourceConfig
from resources.model_resource.model_resource import ModelResourceConfig
from resources.repo_setup_resource import RepoSetupResourceConfig
from resources.resource_type import ResourceType
from utils.logger import get_main_logger
from workflows.base_workflow import BaseWorkflow

logger = get_main_logger(__name__)


class ExploitPhase(BountyPhase):
    """
    ExploitPhase is responsible for attempting to exploit vulnerabilities in the target system.
    """

    AGENT_CLASSES: List[Type[BaseAgent]] = [ExecutorAgent, ExploitAgent]

    def __init__(self, workflow: "BaseWorkflow", **kwargs):
        """
        Initialize the ExploitPhase.

        Args:
            workflow (BaseWorkflow): The parent workflow.
            **kwargs: Additional keyword arguments.
        """
        super().__init__(workflow, **kwargs)

    def define_agents(self) -> Dict[str, Tuple[Type[BaseAgent], Optional[AgentConfig]]]:
        """
        Define the agents required for the ExploitPhase.

        Returns:
            Dict[str, Tuple[Type[BaseAgent], Optional[AgentConfig]]]: A dictionary mapping agent names to their types and configurations.
        """
        executor_config = AgentConfig()

        exploit_config = ExploitAgentConfig(
            bounty_dir=self.bounty_dir,
            task_dir=self.workflow.task_dir,
            tmp_dir=self.tmp_dir,
            submit=self.submit,
            install_command=self.workflow.repo_metadata.get("install_command"),
        )

        return {
            "executor_agent": (ExecutorAgent, executor_config),
            "exploit_agent": (ExploitAgent, exploit_config),
        }

    def define_resources(self) -> List[Tuple[ResourceType, BaseResourceConfig]]:
        """
        Define resource classes and their configurations required by the ExploitPhase.

        Returns:
            List[Tuple[DefaultResource, ResourceConfig]].
        """
        logger.debug(f"Entering define_resources for ExploitPhase")

        input_verify_files_dir_name = "verify_files"

        files_dir_name: str = self.workflow.bounty_metadata.get("files_dir", "codebase")
        vulnerable_commit: str = self.workflow.bounty_metadata.get(
            "vulnerable_commit", "main"
        )

        target_hosts = [self.workflow.repo_metadata["target_host"]]
        target_hosts.extend(self.workflow.bounty_metadata.get("bounty_setup_hosts", []))

        resource_configs: List[Tuple[ResourceType, BaseResourceConfig]] = [
            (
                ResourceType.MODEL,
                ModelResourceConfig.create(
                    model=self.model,
                    use_helm=self.helm,
                    use_mock_model=self.use_mock_model,
                    max_input_tokens=self.params.get("max_input_tokens"),
                    max_output_tokens=self.params.get("max_output_tokens"),
                ),
            ),
            (
                ResourceType.INIT_FILES,
                InitFilesResourceConfig(
                    task_dir=self.workflow.task_dir,
                    files_dir_name=files_dir_name,
                    tmp_dir=self.tmp_dir,
                    preserve_tmp=self.preserve_tmp,
                    input_verify_files_dir_name=input_verify_files_dir_name,
                    output_agent_files_name=self.output_agent_files_name,
                    bounty_number=self.bounty_number,
                    vulnerable_commit=vulnerable_commit,
                ),
            ),
            (
                ResourceType.KALI_ENV,
                KaliEnvResourceConfig(
                    task_dir=self.workflow.task_dir,
                    bounty_number=self.workflow.bounty_number,
                    volumes={
                        str(self.tmp_dir.resolve()): {"bind": "/app", "mode": "rw"},
                    },
                    target_hosts=target_hosts,
                    install_command=self.workflow.repo_metadata.get("install_command"),
                    is_python=self.workflow.repo_metadata.get("is_python"),
                    disable_cleanup=self.preserve_tmp,
                ),
            ),
            (ResourceType.DOCKER, DockerResourceConfig()),
            (ResourceType.MEMORY, MemoryResourceConfig()),
        ]

        resource_configs += get_setup_resources(
            task_dir=self.workflow.task_dir, bounty_number=self.bounty_number
        )

        logger.debug(f"Exiting define_resources for ExploitPhase")
        return resource_configs

    async def run(self, prev_phase_message: PhaseMessage) -> PhaseMessage:
        """
        Run the exploit phase, with an environment preflight check performed once
        before any agent iterations. The preflight uses the PROVIDED exploit (bounty
        `exploit_files`) to validate that:
        - verify succeeds on the vulnerable state, and
        - verify fails after applying the official patch.
        """
        logger.info(
            f"running Phase {self.name} starting at iteration {self.iteration_count}"
        )

        if self.iteration_count == 0 and (
            not hasattr(self, "_phase_message") or not self._phase_message
        ):
            self._phase_message = PhaseMessage(
                phase_id=self.name,
                max_iterations=self.phase_config.max_iterations,
                phase_idx=self.phase_config.phase_idx,
                prev=prev_phase_message,
            )
            self._initialize_last_agent_message(prev_phase_message)

        # Preflight environment sanity check (once)
        if self.iteration_count == 0 and not getattr(self, "_env_preflight_done", False):
            setattr(self, "_env_preflight_done", True)

            exploit_agent = next(
                (a for _name, a in self.agents if isinstance(a, ExploitAgent)), None
            )
            if exploit_agent is None:
                env_result = {
                    "passed": False,
                    "error_reason": "ExploitAgent not available for env preflight.",
                }
            else:
                # Preflight environment check: official exploit must be a valid exploit
                env_result = await exploit_agent.preflight_environment_check()

            # Persist in workflow log metadata for downstream aggregation/state files
            if self.workflow.workflow_message.additional_metadata is None:
                self.workflow.workflow_message.additional_metadata = {}
            self.workflow.workflow_message.additional_metadata["env_preflight"] = env_result

            if not env_result.get("passed", False):
                reason = env_result.get("error_reason") or "Unknown env preflight failure."
                logger.error(f"Env preflight failed: {reason}")
                self._phase_message.set_summary("env_preflight_failed")
                self._phase_message.set_complete()
                self._finalize_phase()
                log_message(self._phase_message)
                return self._phase_message

        # Fall back to BasePhase.run logic for iterations
        start_count = self.iteration_count
        for _iteration_num in range(start_count, self.phase_config.max_iterations):
            if self._phase_message.complete:
                break

            await self._handle_interactive_mode()
            await self._run_iteration()

            if self._phase_message.complete:
                self._phase_message.set_submit()
                break

            self.iteration_count += 1

        if not self._phase_message.complete:
            await self._run_iteration(check=True)
            summary = "no_submission"
            if self._last_agent_message.success:
                self._phase_message.set_success()
                summary += "/success"
            else:
                summary += "/failure"
            self._phase_message.set_summary(summary)

        self._finalize_phase()
        log_message(self._phase_message)
        return self._phase_message

    async def run_one_iteration(
        self,
        phase_message: PhaseMessage,
        agent_instance: Any,
        previous_output: Optional[Message],
    ) -> Message:
        """
        Run a single iteration of the ExploitPhase.

        Args:
            phase_message (PhaseMessage): The current phase message.
            agent_instance (Any): The agent instance to run.
            previous_output (Optional[Message]): The output from the previous iteration.

        Returns:
            Message: The resulting message from the agent.
        """
        input_list: List[Message] = []
        if previous_output is not None:
            input_list.append(previous_output)

        message: Message = await agent_instance.run(input_list)

        if isinstance(agent_instance, ExploitAgent):
            summary = ""
            phase_message.set_summary("")
            if message.submission:
                logger.status("Exploit submitted!", message.success)
                summary += "receive_submission"
                phase_message.set_complete()
            else:
                summary += "no_submission"
            if message.success:
                logger.status("Exploit successful!", True)
                summary += "/success"
                phase_message.set_complete()
                phase_message.set_success()
            else:
                summary += "/failure"
            phase_message.set_summary(summary)

        return message
