import shutil
import sys
from pathlib import Path
from unittest.mock import AsyncMock, MagicMock, patch

import pytest
from tenacity import RetryError

from agents.exploit_agent.exploit_agent import ExploitAgent, ExploitAgentConfig
from messages.action_messages.action_message import ActionMessage
from messages.agent_messages.agent_message import AgentMessage
from messages.agent_messages.exploit_agent_message import ExploitAgentMessage
from resources.base_setup_resource import BaseSetupResource
from resources.resource_type import ResourceType
from utils.file_utils import apply_patch_to_bounty


@pytest.fixture
def agent_config(tmp_path):
    bounty_dir = tmp_path / "bounty"
    task_dir = tmp_path / "task"
    tmp_dir = tmp_path / "tmp"
    bounty_dir.mkdir()
    task_dir.mkdir()
    tmp_dir.mkdir()
    return ExploitAgentConfig(
        bounty_dir=bounty_dir, task_dir=task_dir, tmp_dir=tmp_dir, submit=False
    )


@pytest.fixture
def exploit_agent(agent_config):
    return ExploitAgent(agent_id="exploit_test", agent_config=agent_config)


@pytest.fixture
def mock_prev_message():
    return AgentMessage(agent_id="prev_agent")


@pytest.fixture
def mock_resources():
    """Create mock resources for testing."""
    resources = MagicMock()
    resources.repo_setup = MagicMock(spec=BaseSetupResource)
    resources.repo_setup.resource_id = "repo_setup"
    resources.repo_setup.restart = MagicMock()

    resources.bounty_setup = MagicMock(spec=BaseSetupResource)
    resources.bounty_setup.resource_id = "bounty_setup"
    resources.bounty_setup.restart = MagicMock()

    # Mock the has_bound method
    resources.has_bound = lambda resource_type: resource_type in {
        ResourceType.REPO_SETUP,
        ResourceType.BOUNTY_SETUP,
    }

    return resources


@pytest.mark.asyncio
async def test_run_skips_if_no_exploit_script(exploit_agent, mock_prev_message):
    message = await exploit_agent.run([mock_prev_message])
    assert "No exploit script detected" in message.message


@pytest.mark.asyncio
async def test_reject_submission_when_no_exploit_script(
    exploit_agent, mock_prev_message
):
    """Test that ExploitAgent rejects a submission when no exploit script is detected.
    This should happen even when submit=True and the previous message has submission=True.
    """
    # Configure the agent for submissions
    exploit_agent.submit = True

    # Create a mock executor agent message with submission=True
    from messages.agent_messages.executor_agent_message import ExecutorAgentMessage

    executor_message = ExecutorAgentMessage(
        agent_id="executor_agent", message="Test submission message", submission=True
    )

    # Make sure exploit script path returns False when checked for existence
    with patch.object(Path, "exists", return_value=False):
        # Run the agent with the submission message
        result = await exploit_agent.run([executor_message])

        # Verify the agent rejected the submission correctly
        assert result.submission is False
        assert "No exploit script detected" in result.message


@pytest.mark.asyncio
async def test_run_skips_if_no_git_changes(exploit_agent, mock_prev_message):
    script_path = exploit_agent.exploit_files_dir / "exploit.sh"
    script_path.write_text("#!/bin/bash\necho Hello")
    script_path.chmod(0o755)

    with patch(
        "agents.exploit_agent.exploit_agent.git_has_changes", return_value=False
    ):
        message = await exploit_agent.run([mock_prev_message])
        assert "No changes to exploit files detected" in message.message


@pytest.mark.asyncio
async def test_validate_exploit_script_success_flow(exploit_agent):
    exploit_agent.last_exploit_agent_message = ExploitAgentMessage(agent_id="agent_1")

    with (
        patch.object(exploit_agent, "_run_exploit_verify", side_effect=[0, 1]),
        patch(
            "agents.exploit_agent.exploit_agent.apply_patch_to_bounty",
            return_value=True,
        ),
        patch("agents.exploit_agent.exploit_agent.git_commit"),
        patch("agents.exploit_agent.exploit_agent.git_reset"),
    ):
        await exploit_agent.validate_exploit_script()
        assert "Exploit has meet all success criteria." in "\n".join(
            exploit_agent.step_history
        )


@pytest.mark.asyncio
async def test_validate_exploit_script_verify_fails(exploit_agent):
    exploit_agent.last_exploit_agent_message = ExploitAgentMessage(agent_id="agent_1")

    with (
        patch.object(exploit_agent, "_run_exploit_verify", side_effect=[0, 1]),
        patch(
            "agents.exploit_agent.exploit_agent.apply_patch_to_bounty",
            return_value=True,
        ),
        patch("agents.exploit_agent.exploit_agent.git_reset"),
    ):
        await exploit_agent.validate_exploit_script()
        assert "Exploit verification failed after patch." in "\n".join(
            exploit_agent.step_history
        )


@pytest.mark.asyncio
async def test_validate_exploit_script_raises_and_sets_failure(
    exploit_agent, mock_prev_message
):
    script_path = exploit_agent.exploit_files_dir / "exploit.sh"
    script_path.write_text("#!/bin/bash\necho Hello")
    script_path.chmod(0o755)

    with (
        patch("agents.exploit_agent.exploit_agent.git_has_changes", return_value=True),
        patch("agents.exploit_agent.exploit_agent.git_commit"),
        patch.object(
            exploit_agent, "validate_exploit_script", side_effect=Exception("Crash")
        ),
        patch("agents.exploit_agent.exploit_agent.git_reset"),
    ):
        with pytest.raises(Exception):
            await exploit_agent.run([mock_prev_message])


@pytest.fixture
def null_streams():
    """A fixture to nullify stdout and stderr during test execution."""

    class NullStream:
        def write(self, *args, **kwargs):
            pass

        def flush(self, *args, **kwargs):
            pass

    real_stdout = sys.stdout
    real_stderr = sys.stderr

    sys.stdout = NullStream()
    sys.stderr = NullStream()

    yield

    sys.stdout = real_stdout
    sys.stderr = real_stderr


@pytest.mark.asyncio
async def test_run_command_async_error(exploit_agent, null_streams):
    """Test _run_exploit_verify with a failing run_command_async."""
    # Setup the mocks
    exploit_agent.resources = MagicMock()
    exploit_agent.resources.docker.run = AsyncMock(
        return_value=ActionMessage(resource_id="docker", message="issue")
    )

    # Mock the resource_id for deterministic script paths
    exploit_agent.resources.docker.resource_id = "test_docker"

    # Create folders needed
    exploit_agent.tmp_dir.mkdir(exist_ok=True)
    exploit_agent.task_codebase.mkdir(exist_ok=True)

    # Create verify script
    exploit_agent.verify_files_dir.mkdir(exist_ok=True)
    exploit_agent.verify_script.write_text("#!/bin/bash\necho verify")
    exploit_agent.verify_files_dir.chmod(0o755)

    # Create run_exploit.sh script
    script_path = exploit_agent.tmp_dir / "exploit_files" / "run_exploit.sh"
    script_path.write_text("#!/bin/bash\necho test")
    script_path.chmod(0o755)

    # Patch the necessary functions
    with (
        patch(
            "agents.exploit_agent.exploit_agent.run_command_async",
            side_effect=Exception("fail"),
        ),
        patch.object(exploit_agent, "restart_resources", return_value=True),
        patch(
            "agents.exploit_agent.exploit_agent.git_clean"
        ),  # Mock git_clean to prevent filesystem operations
        patch("builtins.open", new_callable=MagicMock),  # Mock file operations
    ):
        # Run the test - the null_streams fixture handles stdout/stderr
        result = await exploit_agent._run_exploit_verify()
        assert result is None


def test_apply_patch_to_bounty_success(agent_config):
    metadata = {"patch": {"source.py": "dest.py"}}
    source = agent_config.bounty_dir / "source.py"
    dest = agent_config.task_dir / "dest.py"
    source.write_text("patched code")
    metadata_path = agent_config.bounty_dir / "bounty_metadata.json"
    metadata_path.write_text(str(metadata).replace("'", '"'))

    assert apply_patch_to_bounty(agent_config.bounty_dir, agent_config.task_dir) is True
    assert dest.exists()


def test_apply_patch_to_bounty_failure(agent_config):
    metadata = {"patch": {"missing.py": "dest.py"}}
    metadata_path = agent_config.bounty_dir / "bounty_metadata.json"
    metadata_path.write_text(str(metadata).replace("'", '"'))

    assert (
        apply_patch_to_bounty(agent_config.bounty_dir, agent_config.task_dir) is False
    )


def test_apply_patch_to_bounty_no_metadata_file(agent_config):
    with pytest.raises(RuntimeError, match="No bounty metadata file found."):
        apply_patch_to_bounty(agent_config.bounty_dir, agent_config.task_dir)


def test_apply_patch_to_bounty_invalid_json(agent_config):
    metadata_path = agent_config.bounty_dir / "bounty_metadata.json"
    metadata_path.write_text("not json")

    result = apply_patch_to_bounty(agent_config.bounty_dir, agent_config.task_dir)
    assert result is False


def test_apply_patch_to_bounty_no_patch_key(agent_config):
    metadata = {"something_else": {}}
    metadata_path = agent_config.bounty_dir / "bounty_metadata.json"
    metadata_path.write_text(str(metadata).replace("'", '"'))

    with pytest.raises(
        RuntimeError, match="Patch required for bounty. No patch found."
    ):
        apply_patch_to_bounty(agent_config.bounty_dir, agent_config.task_dir)


def test_restart_resources_order(exploit_agent):
    restart_calls = []

    mock_repo = MagicMock()
    mock_repo.resource_id = "repo_setup"
    mock_bounty = MagicMock()
    mock_bounty.resource_id = "bounty_setup"

    exploit_agent.resources.repo_setup = mock_repo
    exploit_agent.resources.bounty_setup = mock_bounty
    exploit_agent.resources.has_bound = lambda x: True

    def mock_restart(r):
        restart_calls.append(r.resource_id)
        return True

    with patch.object(exploit_agent, "_restart_resource", side_effect=mock_restart):
        exploit_agent.restart_resources()

    assert restart_calls == ["repo_setup", "bounty_setup"]


def test_serialization_roundtrip(agent_config):
    agent = ExploitAgent(agent_id="ser_test", agent_config=agent_config)
    data = agent.to_dict()
    restored = ExploitAgent.from_dict(data)
    assert restored.bounty_dir == agent.bounty_dir


@pytest.mark.asyncio
async def test_validate_exploit_script_patching_both_directories(exploit_agent):
    """Test that code continues only if both patching locations succeed (AND logic)."""
    exploit_agent.last_exploit_agent_message = ExploitAgentMessage(agent_id="agent_1")

    # Create tmp_codebase directory
    exploit_agent.tmp_codebase.mkdir(parents=True, exist_ok=True)

    # Test four scenarios with different mock return values for apply_patch_to_bounty
    test_scenarios = [
        # Scenario 1: both succeed - should proceed
        [True, True],
        # Scenario 2: task_dir succeeds, tmp_dir fails - should fail
        [True, False],
        # Scenario 3: task_dir fails, tmp_dir succeeds - should fail
        [False, True],
        # Scenario 4: both fail - should fail
        [False, False],
    ]

    # Test success scenario (both patching attempts succeed)
    with (
        patch.object(exploit_agent, "_run_exploit_verify", side_effect=[0, 1]),
        patch(
            "agents.exploit_agent.exploit_agent.apply_patch_to_bounty",
            side_effect=test_scenarios[0],
        ),
        patch("agents.exploit_agent.exploit_agent.git_commit") as mock_git_commit,
        patch("agents.exploit_agent.exploit_agent.git_reset") as mock_git_reset,
    ):
        # Reset step history
        exploit_agent.step_history = []
        await exploit_agent.validate_exploit_script()

        # Verify both were reset in the finally block
        git_reset_calls = mock_git_reset.call_args_list
        assert len(git_reset_calls) == 2
        assert git_reset_calls[0][0][0] == exploit_agent.task_codebase
        assert git_reset_calls[1][0][0] == exploit_agent.tmp_codebase

        # When both patches succeed, validation should proceed successfully
        assert "Applied patch to the vulnerability." in "\n".join(
            exploit_agent.step_history
        )
        assert "Exploit has meet all success criteria." in "\n".join(
            exploit_agent.step_history
        )

    # Test the three failure scenarios (when at least one patch fails)
    for scenario in test_scenarios[1:]:  # Test all failure scenarios
        with (
            patch.object(
                exploit_agent, "_run_exploit_verify", side_effect=[0]
            ),  # Only called once before patch
            patch(
                "agents.exploit_agent.exploit_agent.apply_patch_to_bounty",
                side_effect=scenario,
            ),
            patch("agents.exploit_agent.exploit_agent.git_reset") as mock_git_reset,
        ):
            # Reset step history
            exploit_agent.step_history = []
            await exploit_agent.validate_exploit_script()

            # Check if the failure message was logged
            assert "Failed to apply exploit patch." in "\n".join(
                exploit_agent.step_history
            )
            # Verify exploit verification was NOT run after failed patching
            assert exploit_agent._run_exploit_verify.call_count == 1


def test_verify_file_directories_created(exploit_agent):
    """Test that verify_files_dir and verify_script paths are correctly set."""
    assert exploit_agent.verify_files_dir == exploit_agent.tmp_dir / "verify_files"
    assert exploit_agent.verify_script == exploit_agent.verify_files_dir / "verify.sh"


@pytest.mark.asyncio
async def test_env_preflight_passes_when_provided_exploit_flips_verify(exploit_agent):
    # Create PROVIDED exploit_files in the bounty dir
    provided_dir = exploit_agent.bounty_dir / "exploit_files"
    provided_dir.mkdir(parents=True, exist_ok=True)
    (provided_dir / "exploit.sh").write_text("#!/bin/bash\necho exploit\n")

    with (
        patch.object(exploit_agent, "_run_exploit_verify", side_effect=[0, 1]),
        patch(
            "agents.exploit_agent.exploit_agent.apply_patch_to_bounty",
            return_value=True,
        ) as mock_apply_patch,
        patch("agents.exploit_agent.exploit_agent.git_commit") as mock_git_commit,
    ):
        result = await exploit_agent.preflight_environment_check()

    assert result["passed"] is True
    assert result["verify_before_exit_code"] == 0
    assert result["verify_after_exit_code"] == 1
    assert mock_apply_patch.call_count == 2
    assert mock_git_commit.call_count == 1
    # Preflight cleanup should leave exploit_files/ present for the real agent run.
    assert exploit_agent.exploit_files_dir.exists()
    assert exploit_agent.exploit_files_dir.is_dir()


@pytest.mark.asyncio
async def test_env_preflight_fails_when_provided_exploit_does_not_verify_before_patch(
    exploit_agent,
):
    provided_dir = exploit_agent.bounty_dir / "exploit_files"
    provided_dir.mkdir(parents=True, exist_ok=True)
    (provided_dir / "exploit.sh").write_text("#!/bin/bash\necho exploit\n")

    with (
        patch.object(exploit_agent, "_run_exploit_verify", return_value=1),
        patch(
            "agents.exploit_agent.exploit_agent.apply_patch_to_bounty",
            return_value=True,
        ) as mock_apply_patch,
        patch("agents.exploit_agent.exploit_agent.git_commit"),
    ):
        result = await exploit_agent.preflight_environment_check()

    assert result["passed"] is False
    assert result["verify_before_exit_code"] == 1
    assert mock_apply_patch.call_count == 0
    assert exploit_agent.exploit_files_dir.exists()
    assert exploit_agent.exploit_files_dir.is_dir()


@pytest.mark.asyncio
async def test_env_preflight_fails_when_verify_does_not_fail_after_patch(exploit_agent):
    provided_dir = exploit_agent.bounty_dir / "exploit_files"
    provided_dir.mkdir(parents=True, exist_ok=True)
    (provided_dir / "exploit.sh").write_text("#!/bin/bash\necho exploit\n")

    with (
        patch.object(exploit_agent, "_run_exploit_verify", side_effect=[0, 0]),
        patch(
            "agents.exploit_agent.exploit_agent.apply_patch_to_bounty",
            return_value=True,
        ) as mock_apply_patch,
        patch("agents.exploit_agent.exploit_agent.git_commit"),
    ):
        result = await exploit_agent.preflight_environment_check()

    assert result["passed"] is False
    assert result["verify_before_exit_code"] == 0
    assert result["verify_after_exit_code"] == 0
    assert mock_apply_patch.call_count == 2
    assert exploit_agent.exploit_files_dir.exists()
    assert exploit_agent.exploit_files_dir.is_dir()


def test_remove_verify_files(exploit_agent):
    """Test that _remove_verify_files removes directory if it exists."""
    # Create the directory
    verify_dir = exploit_agent.verify_files_dir
    verify_dir.mkdir(parents=True, exist_ok=True)
    test_file = verify_dir / "test.txt"
    test_file.write_text("test content")

    # Verify directory exists before removal
    assert verify_dir.exists()
    assert test_file.exists()

    # Remove the directory
    exploit_agent._remove_verify_files(verify_dir)

    # Verify directory no longer exists
    assert not verify_dir.exists()
    assert not test_file.exists()


def test_copy_verify_files(exploit_agent):
    """Test that _copy_verify_files copies directory contents correctly."""
    # Create source directory with test files
    source_dir = exploit_agent.bounty_dir / "verify_files"
    source_dir.mkdir(parents=True, exist_ok=True)
    source_file = source_dir / "test.txt"
    source_file.write_text("test content")
    source_script = source_dir / "verify.sh"
    source_script.write_text("#!/bin/bash\necho test")
    source_script.chmod(0o755)

    # Create destination directory
    dest_dir = exploit_agent.verify_files_dir

    # Copy the files
    exploit_agent._copy_verify_files(source_dir, dest_dir)

    # Verify files were copied correctly
    assert dest_dir.exists()
    assert (dest_dir / "test.txt").exists()
    assert (dest_dir / "test.txt").read_text() == "test content"
    assert (dest_dir / "verify.sh").exists()
    assert (dest_dir / "verify.sh").read_text() == "#!/bin/bash\necho test"


def test_reset_verify_files(exploit_agent):
    """Test that reset_verify_files removes existing directory and copies from source."""
    # Create original verify_files directory
    orig_dir = exploit_agent.bounty_dir / "verify_files"
    orig_dir.mkdir(parents=True, exist_ok=True)
    orig_file = orig_dir / "verify.sh"
    orig_file.write_text("#!/bin/bash\necho original")
    orig_file.chmod(0o755)

    # Create existing verify_files directory with different content
    verify_dir = exploit_agent.verify_files_dir
    verify_dir.mkdir(parents=True, exist_ok=True)
    verify_file = verify_dir / "verify.sh"
    verify_file.write_text("#!/bin/bash\necho old")
    verify_file.chmod(0o755)

    # Reset verify files
    exploit_agent.reset_verify_files()

    # Verify files were reset correctly
    assert verify_dir.exists()
    assert verify_file.exists()
    assert verify_file.read_text() == "#!/bin/bash\necho original"


def test_reset_verify_files_not_exists(exploit_agent):
    """Test that reset_verify_files raises exception when directory doesn't exist."""
    # Ensure verify_files directory doesn't exist
    orig_dir = exploit_agent.bounty_dir / "verify_files"
    if orig_dir.exists():
        shutil.rmtree(orig_dir)

    # Verify exception is raised
    with pytest.raises(
        Exception, match=f"Verify files directory not found at {orig_dir}"
    ):
        exploit_agent.reset_verify_files()


@pytest.mark.asyncio
async def test_reset_verify_files_in_run_exploit_verify(exploit_agent):
    """Test that _run_exploit_verify calls reset_verify_files and uses the right directory."""
    # Set up necessary fixture state
    exploit_agent.last_exploit_agent_message = ExploitAgentMessage(agent_id="agent_1")
    exploit_agent.last_action_message = None

    # Create verify files directory in the bounty directory
    orig_dir = exploit_agent.bounty_dir / "verify_files"
    orig_dir.mkdir(parents=True, exist_ok=True)
    orig_file = orig_dir / "verify.sh"
    orig_file.write_text("#!/bin/bash\necho verify")
    orig_file.chmod(0o755)

    # Setup mocks
    mock_run_command = AsyncMock()
    mock_run_command.return_value.returncode = 0
    mock_run_command.return_value.stdout = "verify output"

    # Set up Docker mock for the first part of _run_exploit_verify
    docker_mock = MagicMock()
    docker_mock.resource_id = "test_docker"
    docker_mock.run = AsyncMock()
    docker_mock.run.return_value = ActionMessage(
        resource_id="docker", message="exploit output"
    )
    exploit_agent.resources = MagicMock()
    exploit_agent.resources.docker = docker_mock

    # Create a spy on reset_verify_files to track calls without changing behavior
    reset_spy = patch.object(
        exploit_agent, "reset_verify_files", wraps=exploit_agent.reset_verify_files
    )

    with (
        patch("agents.exploit_agent.exploit_agent.run_command_async", mock_run_command),
        patch("agents.exploit_agent.exploit_agent.git_clean"),
        reset_spy,
    ):
        # Run the method
        result = await exploit_agent._run_exploit_verify()

        # Verify run_command_async was called with correct working directory
        calls = mock_run_command.call_args_list
        assert len(calls) > 0

        # Find the call for verify.sh
        verify_call = next(
            (call for call in calls if call[0][0] == "bash verify.sh"), None
        )
        assert verify_call is not None
        assert verify_call[1]["work_dir"] == exploit_agent.verify_files_dir

        # Verify the exit code was returned
        assert result == 0


def test_restart_resources_success(exploit_agent, mock_resources):
    """Test resource restart when all resources restart successfully."""
    # Set up the mock resources
    exploit_agent.resources = mock_resources

    exploit_agent.restart_resources()

    mock_resources.repo_setup.restart.assert_called_once()
    mock_resources.bounty_setup.restart.assert_called_once()


def test_restart_resources_repo_failure(exploit_agent, mock_resources):
    """Test resource restart when repo_setup fails."""
    # Set up the mock resources
    exploit_agent.resources = mock_resources
    mock_resources.repo_setup.restart.side_effect = Exception("Resource failure")

    # Expect an exception to be raised after retries
    with pytest.raises(Exception):
        exploit_agent.restart_resources()

    # Verify the restart was called the right number of times
    assert mock_resources.repo_setup.restart.call_count == 3
    # Bounty setup should not be called since repo setup failed
    mock_resources.bounty_setup.restart.assert_not_called()


@patch("agents.exploit_agent.exploit_agent.logger")
def test_restart_resources_retry_behavior(mock_logger, exploit_agent, mock_resources):
    """Test that the restart_resources method retries when resources fail."""
    # Set up the mock resources
    exploit_agent.resources = mock_resources

    # Create a counter to track calls
    call_counter = [0]  # Use a list so it can be modified inside the function

    def side_effect(*args, **kwargs):
        call_counter[0] += 1
        if call_counter[0] == 1:
            raise Exception("First failure")
        elif call_counter[0] == 2:
            raise Exception("Second failure")
        # Third call succeeds (returns None)

    # Set up the side effect
    mock_resources.repo_setup.restart.side_effect = side_effect

    exploit_agent.restart_resources()

    # Verify the method was called three times (2 failures + 1 success)
    assert call_counter[0] == 3
    assert mock_resources.repo_setup.restart.call_count == 3
    assert mock_resources.bounty_setup.restart.call_count == 1

    repo_errors = [
        call
        for call in mock_logger.error.call_args_list
        if "Failed to restart repo_setup resource" in str(call)
    ]
    assert len(repo_errors) >= 2

    all_calls_str = str(mock_logger.error.call_args_list)
    assert "First failure" in all_calls_str
    assert "Second failure" in all_calls_str


def test_restart_resources_all_retries_fail(exploit_agent, mock_resources):
    """Test that an exception is raised when all retries fail."""
    # Set up the mock resources
    exploit_agent.resources = mock_resources

    # Make all restart attempts fail
    mock_resources.repo_setup.restart.side_effect = Exception(
        "Failed to restart resources."
    )

    # Should raise RetryError after retries are exhausted
    with pytest.raises(RetryError) as excinfo:
        exploit_agent.restart_resources()

    retry_error = excinfo.value
    last_attempt = retry_error.last_attempt

    if hasattr(last_attempt, "exception"):
        # For Future objects
        underlying_exception = last_attempt.exception()
    else:
        # For non-Future objects (synchronous retries)
        underlying_exception = getattr(
            last_attempt, "_exception", getattr(last_attempt, "exception", None)
        )

    assert "Failed to restart resources." in str(underlying_exception)

    assert mock_resources.repo_setup.restart.call_count == 3
